# Проектирование ПО 

**Software Design** и вот это все
Полезно для всех, особенно если пилишь проект/стартап/попадаешь в большой кровавый энтерпрайз
Александр Киракозов
Учился у Бреслау? Kotlin в JB

###GIF-driven education

* Architectural design
	- компоненты и взаимодействие между ними, высокоуровневое представление
* High-level design
	- подсистемы, модули и их взаимодействие
* Detailed design
	- еще более глубинная нёх

## Основные проблемы
* Сложность задачи
	- перебор со сложностью
	- действительно сложные идейно задачи
* Сильные зависимости между частями
	- спагетти-код
	- все зависит от всего, нельзя выделить небольшую часть
	- надо дробить систему на минимально взаимозависящие части
* Дублирование (кода, идей)
	- фиксить надо в куче мест
	- дублирование _всегда_ зло
	- выделять все, что можно выделить
	- наследственность, делегирование
* Запутанность
	- зависимости и что-то еще

## Способы решения
* Абстрагирование
	- вынести код, обобщить
* Уточнение
	- что отличает одну часть от другой
* Модульность
	- разбивать на независимые модули
* Декомпозиция
	- разделять задачу на подзадачи, которые тоже решать независимо
* Инкапсуляция
	- сокрытие деталей реализации, минимально необходимый интерфейс
* Повторное использование
* "Чистый" код

## Что вообще будет
* Стиль кода
	- Code conventions
	- Читаемость кода
	- Какой код удобно поддерживать
	- Как избегать дублирования
	- Code smell (есть утилиты, которые нормально на это проверяют)
* Проверки корректности
	- Формальные доказательства
	- Автоматические проверки кода
	- Code review и всякий Agile
	- Тесты
* Обработки ошибок
	- мем про Junior vs Middle (первый считает инпут всегда хорошим и кладет на Exception'ы)
	- инпут может быть откровенно кривым, некорректным, пустым (какой-нибудь JSON/XML/ответ от сервера, в мобильной части просто ад и Израиль)
* Модульные тесты (TDD)
	- Test first
	- Пишешь класс, представляешь его интерфейс, тестируешь этот функционал; тест упал -- пофиксил; тесты прошлись -- чистим, радуемся
	- Регрессионное тестирование
	- Continuous integration (в любой момент времени основная ветка выглядит и работает так, что ее можно выпускать в релиз)
	- Если очень хорошо покрывать код тестами, то отпадает необходимость много тыкаться в само приложение, но если программа должна взаимодействовать с внешними компонентами, лучше в реальной среде тоже проверять
	- Интеграционные тесты
* Рефакторинг
	- меняем структуру программы, не затрагивая ее внешнего поведения, с целью улучшения понимания работы
	- "немножко порефукаю" - это в целом иллюзия
	- не утонуть в рефакторинге, пока конкуренты хуячат фичи в продакшн и твой проект становится красивым, но никому не нужным
* Шаблоны проектирования (Design patterns)
	- **"Elements of Reusable Object-Oriented Software"** Gang of Four
	- **"Refactoring ..."** Martin Fowler
	- **"Clean Code"** Robert C. Martin
	- **"Patterns of Enterprise Application Architecture"** Martin Fowler (next-level)
	- **"Working Effectively with Legacy Code"** Michael C. Feathers
	-- спустя несколько лет твой код станет легаси, живи с этим!

## Идеальная практика для курса
* Небольшой реальный проект
* 2-3 человека в команде (каждый отвечает за важную часть проекта)
* Version control (github.com)
* Continuous integration: например, с помощью веб-сервисов прогоняем тесты по всему проекту после каждого коммита
* TDD: уже говорилось - тестами покрываем не от балды
* Code review (сильно помогает на пути к просветлению как жертве, так и палачу)
* На своем кровном проекте потестить все практики курса, проект писать в течение семестра; народу много, поэтому очень много времени уделить каждому проекту вряд ли получится

## Правила игры
* 5-6 лаб (50 баллов)
* Проект (30 баллов)
* Устный зачет (20 баллов)