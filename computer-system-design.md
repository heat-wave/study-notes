# Проектирование ПО 

## Лекция 1

**Software Design** и вот это все
Полезно для всех, особенно если пилишь проект/стартап/попадаешь в большой кровавый энтерпрайз
Александр Киракозов
Учился у Бреслау? Kotlin в JB

### GIF-driven education

* Architectural design
	- компоненты и взаимодействие между ними, высокоуровневое представление
* High-level design
	- подсистемы, модули и их взаимодействие
* Detailed design
	- еще более глубинная нёх

### Основные проблемы
* Сложность задачи
	- перебор со сложностью
	- действительно сложные идейно задачи
* Сильные зависимости между частями
	- спагетти-код
	- все зависит от всего, нельзя выделить небольшую часть
	- надо дробить систему на минимально взаимозависящие части
* Дублирование (кода, идей)
	- фиксить надо в куче мест
	- дублирование _всегда_ зло
	- выделять все, что можно выделить
	- наследственность, делегирование
* Запутанность
	- зависимости и что-то еще

### Способы решения
* Абстрагирование
	- вынести код, обобщить
* Уточнение
	- что отличает одну часть от другой
* Модульность
	- разбивать на независимые модули
* Декомпозиция
	- разделять задачу на подзадачи, которые тоже решать независимо
* Инкапсуляция
	- сокрытие деталей реализации, минимально необходимый интерфейс
* Повторное использование
* "Чистый" код

### Что вообще будет
* Стиль кода
	- Code conventions
	- Читаемость кода
	- Какой код удобно поддерживать
	- Как избегать дублирования
	- Code smell (есть утилиты, которые нормально на это проверяют)
* Проверки корректности
	- Формальные доказательства
	- Автоматические проверки кода
	- Code review и всякий Agile
	- Тесты
* Обработки ошибок
	- мем про Junior vs Middle (первый считает инпут всегда хорошим и кладет на Exception'ы)
	- инпут может быть откровенно кривым, некорректным, пустым (какой-нибудь JSON/XML/ответ от сервера, в мобильной части просто ад и Израиль)
* Модульные тесты (TDD)
	- Test first
	- Пишешь класс, представляешь его интерфейс, тестируешь этот функционал; тест упал -- пофиксил; тесты прошлись -- чистим, радуемся
	- Регрессионное тестирование
	- Continuous integration (в любой момент времени основная ветка выглядит и работает так, что ее можно выпускать в релиз)
	- Если очень хорошо покрывать код тестами, то отпадает необходимость много тыкаться в само приложение, но если программа должна взаимодействовать с внешними компонентами, лучше в реальной среде тоже проверять
	- Интеграционные тесты
* Рефакторинг
	- меняем структуру программы, не затрагивая ее внешнего поведения, с целью улучшения понимания работы
	- "немножко порефукаю" - это в целом иллюзия
	- не утонуть в рефакторинге, пока конкуренты хуячат фичи в продакшн и твой проект становится красивым, но никому не нужным
* Шаблоны проектирования (Design patterns)
	- **"Elements of Reusable Object-Oriented Software"** Gang of Four
	- **"Refactoring ..."** Martin Fowler
	- **"Clean Code"** Robert C. Martin
	- **"Patterns of Enterprise Application Architecture"** Martin Fowler (next-level)
	- **"Working Effectively with Legacy Code"** Michael C. Feathers
	-- спустя несколько лет твой код станет легаси, живи с этим!

### Идеальная практика для курса
* Небольшой реальный проект
* 2-3 человека в команде (каждый отвечает за важную часть проекта)
* Version control (github.com)
* Continuous integration: например, с помощью веб-сервисов прогоняем тесты по всему проекту после каждого коммита
* TDD: уже говорилось - тестами покрываем не от балды
* Code review (сильно помогает на пути к просветлению как жертве, так и палачу)
* На своем кровном проекте потестить все практики курса, проект писать в течение семестра; народу много, поэтому очень много времени уделить каждому проекту вряд ли получится

### Правила игры
* 5-6 лаб (50 баллов)
* Проект (30 баллов)
* Устный зачет (20 баллов)

### Примеры проектов
* Yandex.Disk DropZone
	- этакий дропбокс между яндекс-дисками
* Android app for receipt
	- сканим чек, как-то просекаем, на что сколько потрачено, классифицируем, майним, w/e
* Mobi2Html converter
	- тут все ясно, хотя не архиполезно
* Audio/Video online editor
	- веб-сервис

## Лекция 2

### План
* Хорошие имена и самодокументируемый код
* Работа с NULL

### Имена переменных
* Сразу понятно, что содержит
* Избавляет от необходимости писать комментарии (их пропускают и вообще они не для того)
* Можно понять предметную область кода
* Говорящие имена для класса/метода/локальных переменных
* Выпиливать магические константы

### Имена классов
* существительные!

### Имена методов
* Глагол/глагольная фраза
* Для accessors/mutators/predicates стандартные префиксы: set, get, is
* RIP венгерская нотация
	- в языках удобные и богатые системы типов
	- удобная подсветка в IDE
	- IDE покажет ошибку сразу

### Размерности
* int timeout = 200; --- в какой размерности?
* int timeoutInMs = 200;
* Duration timeout = Duration.***millis***(200);

* long sizeInBytes = 1024;
* DataSize size = DataSize.***fromKiloBytes***(I);

### Общепринятые имена
* Переменные: tmp, i, j
* Manager/Service/Client/DAO (data access object в DB)/Utils
* Parser, Action, Servlet
* Используйте общие в вашем проекте соглашения

### Креатив в меру
* HolyHandGrenade  ---> DeleteItems
* Stroka vs Wtroka
* AndrushaResizeUtils

* Иногда имеет смысл:
	- BleedingEdge.isOnBleedingEdge(uid)

### Хорошие имена
* Названия алгоритмов
* CS-термины
* Математические термины
* Названия паттернов
* Имена из предметной области

* Пример: JobQueue, DepthFirstSearchWalker, HuffmanTree

### Работа с NULL
* Может быть в любом месте программы
* Везде нужны проверки

#### **@Nullable** 
* Напоминает о том, что может быть NPE
* Может быть у возвращаемых значений, полей, параметров и т.д.
#### **@NotNull**
* Метод не должен возвращать null
* Поля, значения и т.д. не могут быть null

#### **Optional**
* Появился в Java8
* Обертка над значением, которая явно говорит, что значение может быть пустым
* Явно говорит, что тут может быть **null**, IDE подсказывают, если get() дергается без предпроверки
* **orElse**
	- Добавляет дефолтное значение, если Optional пустой, или дает кинуть исключение
* Проверка на уровне компиляции
* Минусы:
	- Загромождается код
	- Все-таки можно засунуть **null** (кажется, это опровергли)
	- Создаются лишние объекты
* Правила:
	- В своем коде использовать Optional вместо **null**
	- Это позволит избежать **null**-check
	- **null** внешних библиотеках оборачивать в Optional