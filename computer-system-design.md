# Проектирование ПО 

## Лекция 1

**Software Design** и вот это все

Полезно для всех, особенно если пилишь проект/стартап/попадаешь в большой кровавый энтерпрайз

Александр Киракозов

Учился у Бреслау? 
Kotlin в JB

### GIF-driven education

* Architectural design
	- компоненты и взаимодействие между ними, высокоуровневое представление
* High-level design
	- подсистемы, модули и их взаимодействие
* Detailed design
	- еще более глубинная нёх

### Основные проблемы
* Сложность задачи
	- перебор со сложностью
	- действительно сложные идейно задачи
* Сильные зависимости между частями
	- спагетти-код
	- все зависит от всего, нельзя выделить небольшую часть
	- надо дробить систему на минимально взаимозависящие части
* Дублирование (кода, идей)
	- фиксить надо в куче мест
	- дублирование _всегда_ зло
	- выделять все, что можно выделить
	- наследственность, делегирование
* Запутанность
	- зависимости и что-то еще

### Способы решения
* Абстрагирование
	- вынести код, обобщить
* Уточнение
	- что отличает одну часть от другой
* Модульность
	- разбивать на независимые модули
* Декомпозиция
	- разделять задачу на подзадачи, которые тоже решать независимо
* Инкапсуляция
	- сокрытие деталей реализации, минимально необходимый интерфейс
* Повторное использование
* "Чистый" код

### Что вообще будет
* Стиль кода
	- Code conventions
	- Читаемость кода
	- Какой код удобно поддерживать
	- Как избегать дублирования
	- Code smell (есть утилиты, которые нормально на это проверяют)
* Проверки корректности
	- Формальные доказательства
	- Автоматические проверки кода
	- Code review и всякий Agile
	- Тесты
* Обработки ошибок
	- мем про Junior vs Middle (первый считает инпут всегда хорошим и кладет на Exception'ы)
	- инпут может быть откровенно кривым, некорректным, пустым (какой-нибудь JSON/XML/ответ от сервера, в мобильной части просто ад и Израиль)
* Модульные тесты (TDD)
	- Test first
	- Пишешь класс, представляешь его интерфейс, тестируешь этот функционал; тест упал -- пофиксил; тесты прошлись -- чистим, радуемся
	- Регрессионное тестирование
	- Continuous integration (в любой момент времени основная ветка выглядит и работает так, что ее можно выпускать в релиз)
	- Если очень хорошо покрывать код тестами, то отпадает необходимость много тыкаться в само приложение, но если программа должна взаимодействовать с внешними компонентами, лучше в реальной среде тоже проверять
	- Интеграционные тесты
* Рефакторинг
	- меняем структуру программы, не затрагивая ее внешнего поведения, с целью улучшения понимания работы
	- "немножко порефукаю" - это в целом иллюзия
	- не утонуть в рефакторинге, пока конкуренты хуячат фичи в продакшн и твой проект становится красивым, но никому не нужным
* Шаблоны проектирования (Design patterns)
	- **"Elements of Reusable Object-Oriented Software"** Gang of Four
	- **"Refactoring ..."** Martin Fowler
	- **"Clean Code"** Robert C. Martin
	- **"Patterns of Enterprise Application Architecture"** Martin Fowler (next-level)
	- **"Working Effectively with Legacy Code"** Michael C. Feathers
	-- спустя несколько лет твой код станет легаси, живи с этим!

### Идеальная практика для курса
* Небольшой реальный проект
* 2-3 человека в команде (каждый отвечает за важную часть проекта)
* Version control (github.com)
* Continuous integration: например, с помощью веб-сервисов прогоняем тесты по всему проекту после каждого коммита
* TDD: уже говорилось - тестами покрываем не от балды
* Code review (сильно помогает на пути к просветлению как жертве, так и палачу)
* На своем кровном проекте потестить все практики курса, проект писать в течение семестра; народу много, поэтому очень много времени уделить каждому проекту вряд ли получится

### Правила игры
* 5-6 лаб (50 баллов)
* Проект (30 баллов)
* Устный зачет (20 баллов)

### Примеры проектов
* Yandex.Disk DropZone
	- этакий дропбокс между яндекс-дисками
* Android app for receipt
	- сканим чек, как-то просекаем, на что сколько потрачено, классифицируем, майним, w/e
* Mobi2Html converter
	- тут все ясно, хотя не архиполезно
* Audio/Video online editor
	- веб-сервис

## Лекция 2

### План
* Хорошие имена и самодокументируемый код
* Работа с NULL

### Имена переменных
* Сразу понятно, что содержит
* Избавляет от необходимости писать комментарии (их пропускают и вообще они не для того)
* Можно понять предметную область кода
* Говорящие имена для класса/метода/локальных переменных
* Выпиливать магические константы

### Имена классов
* существительные!

### Имена методов
* Глагол/глагольная фраза
* Для accessors/mutators/predicates стандартные префиксы: set, get, is
* RIP венгерская нотация
	- в языках удобные и богатые системы типов
	- удобная подсветка в IDE
	- IDE покажет ошибку сразу

### Размерности
* int timeout = 200; --- в какой размерности?
* int timeoutInMs = 200;
* Duration timeout = Duration.***millis***(200);

* long sizeInBytes = 1024;
* DataSize size = DataSize.***fromKiloBytes***(I);

### Общепринятые имена
* Переменные: tmp, i, j
* Manager/Service/Client/DAO (data access object в DB)/Utils
* Parser, Action, Servlet
* Используйте общие в вашем проекте соглашения

### Креатив в меру
* HolyHandGrenade  ---> DeleteItems
* Stroka vs Wtroka
* AndrushaResizeUtils

* Иногда имеет смысл:
	- BleedingEdge.isOnBleedingEdge(uid)

### Хорошие имена
* Названия алгоритмов
* CS-термины
* Математические термины
* Названия паттернов
* Имена из предметной области

* Пример: JobQueue, DepthFirstSearchWalker, HuffmanTree

### Работа с NULL
* Может быть в любом месте программы
* Везде нужны проверки

#### **@Nullable** 
* Напоминает о том, что может быть NPE
* Может быть у возвращаемых значений, полей, параметров и т.д.
#### **@NotNull**
* Метод не должен возвращать null
* Поля, значения и т.д. не могут быть null

#### **Optional**
* Появился в Java8
* Обертка над значением, которая явно говорит, что значение может быть пустым
* Явно говорит, что тут может быть **null**, IDE подсказывают, если get() дергается без предпроверки
* **orElse**
	- Добавляет дефолтное значение, если Optional пустой, или дает кинуть исключение
* Проверка на уровне компиляции
* Минусы:
	- Загромождается код
	- Все-таки можно засунуть **null** (кажется, это опровергли)
	- Создаются лишние объекты
* Правила:
	- В своем коде использовать Optional вместо **null**
	- Это позволит избежать **null**-check
	- **null** внешних библиотеках оборачивать в Optional

## Лекция 3

### Корректность программ
* Соответствие программы ее спецификации
* По сути: работа без ошибок

#### Как достигается
* Доказательства алгоритмов
* Формальные верификации (логика Хоара и др.)
* Автоматические проверки кода
* Code review
* Автоматические тесты
* Ручное тестирование

#### Когда обнаружена ошибка?
* До написания кода
* В момент кодирования
* При первом запуске
	- Хорошо: видел только разработчик, быстрое реагирование
---
* На этапе интеграции
* При тестировании
	- Неплохо: ошибка не попала в продукт
	- Видели другие разработчики/тестеры
	- При исправлении нужно вернуться в контекст
---
* На стадии бета-тестирования
* В релизе пользователями
	- Плохо: падает репутация продукта и спрос
	- Часто уже тяжело исправить

#### Суть
* Находить и исправлять ошибки как можно раньше
* Писать без багов нереально
* CI помогает быстро находить ошибки

#### Continuous Integration
* Изменения часто добавляются в основную ветку
* Сборка и запуск тестов на каждый коммит
* Автоматические проверки и деплой в тестовое окружение

#### Кто поможет рано обнаружить ошибки?
* Компилятор
	- статическая типизация
		- сложно перепутать даже порядок параметров
		- используйте Generics
		- избегайте приведения типов и **instanceof** (зачастую нужен просто общий интерфейс)
		- не использовать **reflection** без необходимости
	- контроль доступа
		- инкапсуляция
	- контроль потока исполнения
		- неинициализированные переменные
		- недоступный код
		- обработка исключений
	- аннотации вроде @Override, @Nullable, @NotNull
* Автотесты
* Проверки в коде
* Синтаксические анализаторы

#### Инструменты для статических проверок
* Checkstyle
Можно настраивать для своей команды
	* Наличие **Javadoc**
	* Конвенции наименований атрибутов и методов
	* Ограничение на число параметров в методе
	* Ограниение на длину строк
	* Использование импортов
	* Дублирование кода 
* Findbugs и PMD
Помогают находить возможные баги
	* toString() может вернуть **null**
	* возвращается значение из **finally** блока
	* игнорируется/подавляется исключение
	* неверные проверки на **null**
* Sonar
	* Continuous inspection of code quality

#### Динамические проверки
* Проверять все входные данные
* Проверять параметры методов
* Всегда добавлять "защиту от дурака"

* Что делать, если ошибка произошла
	* Запросить ввод заново
	* Скорректировать входные данные
	* Попробовать обработать сбой
	* Показать пользователю ошибку

* Утверждения в коде (assert)
	* Дополнительные проверки в коде, проверяющие, что все работает правильно
	* При false кидается AssertionError
	* Включается ключиком -ea, можно локализовать где-то

* Программирование по контракту
	* Предусловия -- проверка входных данных метода
	* Постусловия -- проверка результата выполнения метода
	* Инварианты классов -- утверждения о состоянии классов, верные между вызовами методов

	* Часто нужно проверять и с выключенными assert
	* Лучше для этого использовать всякие `IllegalStateException`

* Обработка ошибок
Способы сообщить об ошибке
	* Глобальные переменные с кодом ошибки
	* Возвращать код ошибки в методе
	* Использовать исключения -- предпочтительно
		* Error -- исключения уровня JVM (почти никогда не надо обрабатывать)
		* Unchecked -- наследники RuntimeException (не требуют обязательной декларации и обработки)
			:+ не нужно явно прописывать в коде
			:+ удобны для лямбд

			:- неизвестно, что может бросить метод

		* Checked -- требуют явной обработки (`try/catch` или `throws`)
			:+ проверяются компилятором
			:+ сразу видно, что может бросить метод

			:- неудобны для лямбд
			:- прокидывать надо по стеку до верхних методов